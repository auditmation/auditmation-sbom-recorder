{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import * as core from '@actions/core';\nimport * as exec from '@actions/exec';\nimport { getLogger } from '@auditmation/util-logger';\nimport { newFileService } from '@auditmation/module-auditmation-auditmation-file-service';\nimport {\n  newPlatformApi,\n  PipelineAdminStatusEnum,\n  PipelineFormatEnum,\n  PipelineJobStatusEnum,\n  PipelineExecutionModeEnum,\n  PipelineConnectorTypeEnum,\n  NewBoundaryProduct,\n} from '@zerobias-com/platform-sdk';\nimport { TimeZone, URL, UUID } from '@zerobias-org/types-core-js';\nimport { UUID as OldUUID, URL as OldURL } from '@auditmation/types-core-js';\nimport axios, { type AxiosInstance } from 'axios';\nimport * as fs from 'node:fs';\nimport md5File from 'md5-file';\nimport path from 'node:path';\nimport * as https from 'node:https';\n\nconst logger = getLogger('console', {}, process.env.LOG_LEVEL || 'debug');\n\n// Type Interfaces\ninterface ActionInputs {\n  productId: string;\n  packageName: string;\n  version: string;\n  filePath: string;\n  apiKey: string;\n  orgId: string;\n  url: URL;\n  boundaryId: string;\n}\n\ninterface ExtractedPackageInfo {\n  pkgName: string;\n  version: string;\n  sbomFilePath: string;\n  fileSize: number;\n  checksum: string;\n}\n\ninterface ApiClients {\n  axios: AxiosInstance;\n  fileService: any;\n  platform: any;\n}\n\ninterface Pipeline {\n  id: string;\n  name: string;\n  productId: string;\n  boundaryId: string;\n  description: string;\n  timezone: any;\n  targets: Record<string, unknown>;\n  moduleName: string;\n  format: any;\n  adminStatus: any;\n}\n\ninterface PipelineJob {\n  id: string;\n}\n\ninterface Batch {\n  id: string;\n}\n\ninterface File {\n  id: string;\n  name: string;\n  fileVersionId: string;\n  checksum: string;\n}\n\ninterface Folder {\n  id: string;\n  name: string;\n}\n\ninterface BoundaryProduct {\n  id: string;\n  productId: string;\n}\n\ninterface PackageJson {\n  version: string;\n}\n\ninterface FileUploadResponse {\n  fileVersionId: string;\n}\n\n// Constants\nconst EVIDENCE_DEFINITION_ID = '209010da-70d1-5fa5-babf-91974fa13bd2' as const;\nconst PIPELINE_NAME = 'Auditmation SBOM Recorder' as const;\n\n// Global error handlers\nprocess.on('unhandledRejection', (reason: unknown, promise: Promise<unknown>) => {\n  logger.error('Unhandled Rejection at Promise:', promise);\n  logger.error('Reason:', reason);\n});\n\nprocess.on('uncaughtException', (err: Error) => {\n  logger.error('Uncaught Exception thrown:', err);\n  process.exit(1);\n});\n\n// Helper Functions\nasync function parseActionInputs(): Promise<ActionInputs> {\n  const productId = core.getInput('product-id');\n  const packageInput = core.getInput('package');\n  const vIndex = packageInput.indexOf('@', 1);\n\n  if (vIndex === -1) {\n    throw new Error('Invalid package format. Expected @scope/package@version');\n  }\n\n  let version = packageInput.slice(vIndex + 1);\n  const packageName = packageInput.slice(0, vIndex);\n  const filePath = core.getInput('file-path');\n  const apiKey = core.getInput('api-key');\n  const orgId = core.getInput('org-id');\n\n  const urlInput = core.getInput('url');\n  let url = await URL.parse(urlInput);\n  const hostname = url.hostname.startsWith('api')\n    ? url.hostname\n    : `api.${url.hostname}`;\n  url = await URL.parse(`${url.protocol}://${hostname}`);\n\n  const boundaryId = core.getInput('boundary-id');\n\n  return {\n    productId,\n    packageName,\n    version,\n    filePath,\n    apiKey,\n    orgId,\n    url,\n    boundaryId,\n  };\n}\n\nasync function downloadAndExtractPackage(\n  inputs: ActionInputs\n): Promise<ExtractedPackageInfo> {\n  const { packageName, version: inputVersion, filePath } = inputs;\n\n  // Download package using npm pack\n  let fileName = '';\n  await exec.exec('npm', ['--silent', 'pack', `${packageName}@${inputVersion}`], {\n    listeners: {\n      stdout: (data: Buffer) => {\n        fileName += data.toString();\n      },\n    },\n    cwd: process.cwd(),\n  });\n\n  fileName = fileName.trim();\n\n  // Extract package\n  await exec.exec('sh', ['-c', `tar zxf ${fileName}`]);\n\n  // Get current directory\n  let out = '';\n  const options: exec.ExecOptions = {\n    listeners: {\n      stdout: (data: Buffer) => {\n        out += data.toString();\n      },\n    },\n  };\n  await exec.exec('pwd', [], options);\n  const cwd = out.trim();\n\n  // Construct SBOM file path\n  const sbomFilePath = path.join(cwd, 'package', filePath);\n\n  // Resolve actual version if 'latest' was specified\n  let version = inputVersion;\n  if (version === 'latest') {\n    const pkgJsonPath = path.join(cwd, 'package', 'package.json');\n    const pkgJsonBuffer = fs.readFileSync(pkgJsonPath);\n    const pkgJson = JSON.parse(pkgJsonBuffer.toString('utf8')) as PackageJson;\n    version = pkgJson.version;\n  }\n\n  // Verify SBOM file exists\n  if (!fs.existsSync(sbomFilePath)) {\n    throw new Error(`SBOM file not found: ${sbomFilePath}`);\n  }\n\n  // Get file stats and checksum\n  const stat = fs.statSync(sbomFilePath);\n  const checksum = md5File.sync(sbomFilePath);\n\n  return {\n    pkgName: packageName,\n    version,\n    sbomFilePath,\n    fileSize: stat.size,\n    checksum,\n  };\n}\n\nasync function setupApiClients(inputs: ActionInputs): Promise<ApiClients> {\n  const { url, apiKey, orgId } = inputs;\n\n  const axiosInstance = axios.create({\n    baseURL: url.toString(),\n    headers: {\n      Authorization: `APIKey ${apiKey}`,\n      'dana-org-id': orgId.toString(),\n    },\n  });\n\n  const fileService = newFileService();\n  await fileService.connect({\n    apiKey,\n    orgId: await OldUUID.parse(orgId),\n    url: await OldURL.parse(`${url.toString()}file-service`),\n  });\n\n  const platform = newPlatformApi();\n  await platform.connect({\n    apiKey,\n    orgId: await UUID.parse(orgId),\n    url: `${url.toString()}platform`,\n  });\n\n  // Enable request inspection for debugging\n  platform.enableRequestInspection(true);\n  const inspector = platform.getRequestInspector();\n\n  inspector.onRequest((config: any) => {\n    logger.debug(`\\n\u2192 SDK REQUEST: ${config.method?.toUpperCase()} ${config.url}`);\n    logger.debug('  Headers:', JSON.stringify(config.headers, null, 2));\n    if (config.data) {\n      logger.debug('  Body:', typeof config.data === 'string' ? config.data : JSON.stringify(config.data, null, 2));\n    }\n  });\n\n  inspector.onResponse((response: any) => {\n    logger.debug(`\\n\u2190 SDK RESPONSE: ${response.status} ${response.statusText}`);\n    logger.debug(`  Duration: ${response.duration}ms`);\n    if (response.data) {\n      logger.debug('  Response data:', typeof response.data === 'string' ? response.data : JSON.stringify(response.data, null, 2));\n    }\n  });\n\n  return {\n    axios: axiosInstance,\n    fileService,\n    platform,\n  };\n}\n\nasync function ensureBoundary(\n  clients: ApiClients,\n  inputs: ActionInputs\n): Promise<string> {\n  const { platform } = clients;\n  let { boundaryId } = inputs;\n\n  // Get or create boundary\n  if (!boundaryId) {\n    const boundaries = await platform.getBoundaryApi().listBoundaries();\n    boundaryId = boundaries.items[0].id;\n  }\n  logger.info('Using boundary:', boundaryId);\n\n  return boundaryId;\n}\n\nasync function ensureBoundaryProduct(\n  clients: ApiClients,\n  boundaryId: string,\n  productId: string\n): Promise<string> {\n  const { platform } = clients;\n\n  // Create boundary product (may already exist)\n  logger.info('Creating boundary product...');\n  logger.info('  boundaryId:', boundaryId);\n  logger.info('  productId:', productId);\n  try {\n    const productUUID = await UUID.parse(productId);\n    const payload: NewBoundaryProduct = {\n      name: 'Auditmation',\n      description: '',\n      productIds: [productUUID],\n    };\n    logger.info('  createBoundaryProduct payload:', JSON.stringify(payload));\n\n    const boundaryUUID = await UUID.parse(boundaryId);\n    await platform.getBoundaryApi().createBoundaryProduct(boundaryUUID, payload);\n    logger.info('Boundary product created successfully');\n  } catch (error: any) {\n    logger.info('Boundary product creation failed (may already exist)');\n    logger.info('  Error message:', error.message);\n    if (error.response) {\n      logger.info('  Response status:', error.response.status);\n      logger.info('  Response data:', JSON.stringify(error.response.data));\n    }\n    // Re-throw with context if it's not a \"already exists\" type error\n    const errorMessage = error.response?.data?.message || error.message || '';\n    if (!errorMessage.includes('already exists') && !errorMessage.includes('duplicate')) {\n      const contextError = new Error(`Failed to create boundary product in ensureBoundaryProduct(): ${error.message}`);\n      contextError.stack = `${contextError.stack}\\nCaused by: ${error.stack}`;\n      throw contextError;\n    }\n  }\n\n  // Find the boundary product ID\n  logger.info('Listing boundary products...');\n  try {\n    const boundaryUUID = await UUID.parse(boundaryId);\n    const boundaryProductsResponse = await platform\n      .getBoundaryApi()\n      .listBoundaryProductsByBoundary(boundaryUUID);\n\n    const boundaryProduct = boundaryProductsResponse.items.find(\n      (product: BoundaryProduct) => product.productId.toString() === productId\n    );\n\n    if (!boundaryProduct) {\n      throw new Error(`Boundary product not found for product ID: ${productId}`);\n    }\n\n    logger.info('Boundary product:', boundaryProduct.id);\n    return boundaryProduct.id;\n  } catch (error) {\n    const err = error as Error;\n    const contextError = new Error(`Failed in listBoundaryProductsByBoundary(): ${err.message}`);\n    contextError.stack = `${contextError.stack}\\nCaused by: ${err.stack}`;\n    throw contextError;\n  }\n}\n\nasync function ensurePipeline(\n  clients: ApiClients,\n  boundaryId: string,\n  boundaryProductId: string,\n  productId: string,\n  packageInfo: ExtractedPackageInfo\n): Promise<Pipeline> {\n  const { platform } = clients;\n  const filePrefix = packageInfo.pkgName.replace('@', '').replace('/', '-');\n\n  // Check if pipeline already exists\n  logger.info('Checking for existing pipeline...');\n  try {\n    logger.info('  Searching for pipeline with name:', PIPELINE_NAME);\n\n    // List all pipelines using the SDK\n    const pipelines = await platform.getPipelineApi().list();\n\n    let pipeline: Pipeline;\n    if (pipelines.items.length === 0) {\n      logger.info('Creating new pipeline...');\n      const pipelinePayload = {\n        name: PIPELINE_NAME,\n        productId,\n        boundaryId,\n        boundaryProductId,\n        description: `Auto generated pipeline from ${filePrefix} SBOMs`,\n        timezone: TimeZone.Utc,\n        targets: {},\n        moduleName: 'Auditmation',\n        format: PipelineFormatEnum.File,\n        executionMode: PipelineExecutionModeEnum.Receiver,\n        connectorType: PipelineConnectorTypeEnum.ProductSpecific,\n      };\n      logger.info('  Pipeline payload:', JSON.stringify(pipelinePayload, null, 2));\n      pipeline = await platform.getPipelineApi().create(pipelinePayload);\n      logger.info('Pipeline created successfully');\n    } else {\n      logger.info('Using existing pipeline');\n      [pipeline] = pipelines.items;\n    }\n\n    // Ensure pipeline is enabled (only update if in draft status)\n    if (pipeline.adminStatus === PipelineAdminStatusEnum.Draft) {\n      logger.info('Updating pipeline status from draft to created...');\n      pipeline.adminStatus = PipelineAdminStatusEnum.Created;\n      pipeline = await platform.getPipelineApi().update(pipeline.id, pipeline);\n    } else {\n      logger.info(`Pipeline already in ${pipeline.adminStatus} status, skipping status update`);\n    }\n\n    logger.info('Using pipeline:', pipeline.id);\n    return pipeline;\n  } catch (error) {\n    const err = error as Error;\n    const contextError = new Error(`Failed in ensurePipeline(): ${err.message}`);\n    contextError.stack = `${contextError.stack}\\nCaused by: ${err.stack}`;\n    throw contextError;\n  }\n}\n\nasync function createPipelineJob(\n  clients: ApiClients,\n  pipelineId: string\n): Promise<PipelineJob> {\n  const { platform } = clients;\n\n  const job = await platform.getPipelineJobApi().createPipelineJob({\n    pipelineId,\n    previewMode: false,\n  });\n\n  logger.info('Created job:', job.id);\n  return job;\n}\n\nasync function createBatch(\n  clients: ApiClients,\n  jobId: string,\n  groupId: string\n): Promise<Batch> {\n  const { platform } = clients;\n\n  const batch = await platform.getBatchApi().createBatch({\n    className: 'EvidenceFile',\n    jobId,\n    groupId,\n  });\n\n  logger.info('Created batch:', batch.id);\n  return batch;\n}\n\nasync function ensureFolderStructure(\n  fileService: any,\n  pipelineId: string\n): Promise<string> {\n  // Ensure /pipeline folder exists\n  let foldersResponse = await fileService.getResourceApi().searchResources(\n    undefined,\n    undefined,\n    ['pipeline'],\n    undefined,\n    ['folder'],\n  );\n\n  let pipelineFolderId = foldersResponse.items?.find((f: Folder) => f.name === 'pipeline')?.id;\n\n  if (!pipelineFolderId) {\n    const folder = await fileService.getFolderApi().create({\n      name: 'pipeline',\n    }) as Folder;\n    pipelineFolderId = folder.id;\n  }\n\n  // Ensure /pipeline/{pipelineId} folder exists\n  foldersResponse = await fileService.getResourceApi().searchResources(\n    undefined,\n    undefined,\n    [pipelineId.toString()],\n    undefined,\n    ['folder'],\n  );\n\n  let folderId = foldersResponse.items?.find((f: Folder) => f.name === pipelineId.toString())?.id;\n\n  if (!folderId) {\n    const folder = await fileService.getFolderApi().create({\n      name: pipelineId.toString(),\n      folderId: pipelineFolderId.toString(),\n    }) as Folder;\n    folderId = folder.id;\n  }\n\n  return folderId;\n}\n\nasync function uploadFileContents(\n  url: URL,\n  apiKey: string,\n  orgId: string,\n  fileId: string,\n  filePath: string,\n  fileSize: number,\n  checksum: string\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const fileStream = fs.createReadStream(filePath);\n\n    const opts: https.RequestOptions = {\n      hostname: url.hostname,\n      port: url.port,\n      path: `/file-service/files/${fileId}/upload?checksum=${checksum}`,\n      method: 'POST',\n      protocol: 'https:',\n      headers: {\n        'content-length': fileSize.toString(),\n        'content-type': 'application/json',\n        Authorization: `APIKey ${apiKey}`,\n        'dana-org-id': orgId.toString(),\n      },\n    };\n\n    let responseData = '';\n\n    const req = https.request(opts, (res) => {\n      res.on('data', (chunk: Buffer) => {\n        const chunkStr = chunk.toString();\n        logger.info('Upload chunk received:', chunkStr);\n        responseData += chunkStr;\n      });\n\n      res.on('end', () => {\n        logger.info('File upload completed');\n        try {\n          const data = JSON.parse(responseData) as FileUploadResponse;\n          resolve(data.fileVersionId);\n        } catch {\n          reject(new Error(`Failed to parse upload response: ${responseData}`));\n        }\n      });\n    });\n\n    req.on('error', (err: Error) => {\n      logger.error(`Error uploading file: ${err.message}`);\n      reject(err);\n    });\n\n    fileStream.pipe(req);\n  });\n}\n\nasync function uploadSbomFile(\n  clients: ApiClients,\n  pipelineId: string,\n  packageInfo: ExtractedPackageInfo,\n  inputs: ActionInputs\n): Promise<File> {\n  const { fileService } = clients;\n  const { sbomFilePath, pkgName, version, fileSize, checksum } = packageInfo;\n\n  // Ensure folder structure exists\n  const folderId = await ensureFolderStructure(fileService, pipelineId);\n\n  // Create file record\n  const file = await fileService.getFileApi().create({\n    name: `${pkgName}-${version}.json`,\n    description: `SBOM for ${pkgName}`,\n    folderId,\n    retentionPolicy: {},\n    syncPolicy: {},\n  }) as File;\n\n  logger.info('File:', file.id);\n  logger.info('File object:', JSON.stringify(file, null, 2));\n  let fileVersionId = file.fileVersionId?.toString() || '';\n\n  // Upload file contents if checksum differs\n  if (checksum === file.checksum) {\n    logger.info('File checksum matches, skipping upload');\n  } else {\n    fileVersionId = await uploadFileContents(\n      inputs.url,\n      inputs.apiKey,\n      inputs.orgId,\n      file.id,\n      sbomFilePath,\n      fileSize,\n      checksum\n    );\n    logger.info('File uploaded with new version:', fileVersionId);\n  }\n\n  return {\n    ...file,\n    fileVersionId,\n  };\n}\n\nasync function addBatchItem(\n  clients: ApiClients,\n  batchId: string,\n  file: File,\n  pipelineId: string,\n  fileSize: number\n): Promise<void> {\n  const { platform } = clients;\n\n  const batchImportItem = {\n    payload: {\n      id: file.id,\n      name: file.name,\n      fileVersionId: file.fileVersionId,\n      size: fileSize,\n      mimeType: 'application/json',\n      evidenceDefinition: EVIDENCE_DEFINITION_ID,\n      pipelineId,\n    },\n    rawData: {},\n  };\n\n  logger.info('Adding batch item with payload:', JSON.stringify(batchImportItem, null, 2));\n  const response = await platform.getBatchApi().addBatchItem(batchId, batchImportItem);\n\n  logger.info('Batch item:', response.id);\n}\n\nasync function completePipelineJob(\n  clients: ApiClients,\n  jobId: string\n): Promise<void> {\n  const { platform } = clients;\n\n  await platform.getPipelineJobApi().updatePipelineJob(jobId, {\n    status: PipelineJobStatusEnum.Completed,\n  });\n}\n\nasync function closeBatch(\n  clients: ApiClients,\n  batchId: string\n): Promise<void> {\n  const { platform } = clients;\n\n  await platform.getBatchApi().endBatch(batchId);\n}\n\n// Main function\nasync function run(): Promise<void> {\n  try {\n    // Parse inputs\n    const inputs = await parseActionInputs();\n\n    // Download and extract package\n    const packageInfo = await downloadAndExtractPackage(inputs);\n\n    // Setup API clients\n    const clients = await setupApiClients(inputs);\n\n    // Get or create boundary\n    const boundaryId = await ensureBoundary(clients, inputs);\n\n    // Create boundary product\n    const boundaryProductId = await ensureBoundaryProduct(clients, boundaryId, inputs.productId);\n\n    // Get or create pipeline\n    const pipeline = await ensurePipeline(\n      clients,\n      boundaryId,\n      boundaryProductId,\n      inputs.productId,\n      packageInfo\n    );\n\n    // Create job and batch\n    const job = await createPipelineJob(clients, pipeline.id);\n    const batch = await createBatch(clients, job.id, packageInfo.pkgName);\n\n    // Upload file\n    const file = await uploadSbomFile(\n      clients,\n      pipeline.id,\n      packageInfo,\n      inputs\n    );\n\n    // Add batch item and complete\n    await addBatchItem(clients, batch.id, file, pipeline.id, packageInfo.fileSize);\n    await completePipelineJob(clients, job.id);\n    await closeBatch(clients, batch.id);\n\n    logger.info('SBOM upload completed successfully');\n  } catch (error) {\n    const err = error as Error;\n    logger.error('Error:', err.message);\n    logger.error('Stack:', err.stack);\n    core.setFailed(err.message);\n    process.exit(1);\n  }\n}\n\n// Entry point\nrun().catch((error: Error) => {\n  logger.error('Unhandled error in run():', error);\n  process.exit(1);\n});\n"],
  "mappings": "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",
  "names": ["core", "exec", "import_util_logger", "import_module_auditmation_auditmation_file_service", "import_platform_sdk", "import_types_core_js", "import_axios", "fs", "import_md5_file", "import_node_path", "https", "logger", "EVIDENCE_DEFINITION_ID", "PIPELINE_NAME", "reason", "promise", "err", "parseActionInputs", "productId", "packageInput", "vIndex", "version", "packageName", "filePath", "apiKey", "orgId", "urlInput", "url", "hostname", "boundaryId", "downloadAndExtractPackage", "inputs", "inputVersion", "fileName", "data", "out", "cwd", "sbomFilePath", "path", "pkgJsonPath", "pkgJsonBuffer", "stat", "checksum", "md5File", "setupApiClients", "axiosInstance", "axios", "fileService", "OldUUID", "OldURL", "platform", "inspector", "config", "response", "ensureBoundary", "clients", "ensureBoundaryProduct", "payload", "boundaryUUID", "error", "errorMessage", "contextError", "boundaryProduct", "product", "ensurePipeline", "boundaryProductId", "packageInfo", "filePrefix", "pipelines", "pipeline", "pipelinePayload", "createPipelineJob", "pipelineId", "job", "createBatch", "jobId", "groupId", "batch", "ensureFolderStructure", "foldersResponse", "pipelineFolderId", "f", "folderId", "uploadFileContents", "fileId", "fileSize", "resolve", "reject", "fileStream", "opts", "responseData", "req", "res", "chunk", "chunkStr", "uploadSbomFile", "pkgName", "file", "fileVersionId", "addBatchItem", "batchId", "batchImportItem", "completePipelineJob", "closeBatch", "run"]
}
