import*as f from"@actions/core";import*as P from"@actions/exec";import{getLogger as B}from"@auditmation/util-logger";import{newFileService as x}from"@auditmation/module-auditmation-auditmation-file-service";import{newPlatformApi as F,PipelineAdminStatusEnum as S,PipelineFormatEnum as $,PipelineJobStatusEnum as U,PipelineExecutionModeEnum as R,PipelineConnectorTypeEnum as N}from"@zerobias-com/platform-sdk";import{TimeZone as C,URL as b,UUID as w}from"@zerobias-org/types-core-js";import{UUID as v,URL as J}from"@auditmation/types-core-js";import O from"axios";import*as g from"node:fs";import D from"md5-file";import k from"node:path";import*as E from"node:https";var i=B("console",{},process.env.LOG_LEVEL||"debug"),L="209010da-70d1-5fa5-babf-91974fa13bd2",A="Auditmation SBOM Recorder";process.on("unhandledRejection",(n,t)=>{i.error("Unhandled Rejection at Promise:",t),i.error("Reason:",n)});process.on("uncaughtException",n=>{i.error("Uncaught Exception thrown:",n),process.exit(1)});async function j(){let n=f.getInput("product-id"),t=f.getInput("package"),e=t.indexOf("@",1);if(e===-1)throw new Error("Invalid package format. Expected @scope/package@version");let a=t.slice(e+1),r=t.slice(0,e),s=f.getInput("file-path"),c=f.getInput("api-key"),d=f.getInput("org-id"),o=f.getInput("url"),p=await b.parse(o),m=p.hostname.startsWith("api")?p.hostname:`api.${p.hostname}`;p=await b.parse(`${p.protocol}://${m}`);let u=f.getInput("boundary-id");return{productId:n,packageName:r,version:a,filePath:s,apiKey:c,orgId:d,url:p,boundaryId:u}}async function z(n){let{packageName:t,version:e,filePath:a}=n,r="";await P.exec("npm",["--silent","pack",`${t}@${e}`],{listeners:{stdout:l=>{r+=l.toString()}},cwd:process.cwd()}),r=r.trim(),await P.exec("sh",["-c",`tar zxf ${r}`]);let s="";await P.exec("pwd",[],{listeners:{stdout:l=>{s+=l.toString()}}});let d=s.trim(),o=k.join(d,"package",a),p=e;if(p==="latest"){let l=k.join(d,"package","package.json"),y=g.readFileSync(l);p=JSON.parse(y.toString("utf8")).version}if(!g.existsSync(o))throw new Error(`SBOM file not found: ${o}`);let m=g.statSync(o),u=D.sync(o);return{pkgName:t,version:p,sbomFilePath:o,fileSize:m.size,checksum:u}}async function M(n){let{url:t,apiKey:e,orgId:a}=n,r=O.create({baseURL:t.toString(),headers:{Authorization:`APIKey ${e}`,"dana-org-id":a.toString()}}),s=x();await s.connect({apiKey:e,orgId:await v.parse(a),url:await J.parse(`${t.toString()}file-service`)});let c=F();await c.connect({apiKey:e,orgId:await w.parse(a),url:`${t.toString()}platform`}),c.enableRequestInspection(!0);let d=c.getRequestInspector();return d.onRequest(o=>{i.debug(`
\u2192 SDK REQUEST: ${o.method?.toUpperCase()} ${o.url}`),i.debug("  Headers:",JSON.stringify(o.headers,null,2)),o.data&&i.debug("  Body:",typeof o.data=="string"?o.data:JSON.stringify(o.data,null,2))}),d.onResponse(o=>{i.debug(`
\u2190 SDK RESPONSE: ${o.status} ${o.statusText}`),i.debug(`  Duration: ${o.duration}ms`),o.data&&i.debug("  Response data:",typeof o.data=="string"?o.data:JSON.stringify(o.data,null,2))}),{axios:r,fileService:s,platform:c}}async function V(n,t){let{platform:e}=n,{boundaryId:a}=t;return a||(a=(await e.getBoundaryApi().listBoundaries()).items[0].id),i.info("Using boundary:",a),a}async function K(n,t,e){let{platform:a}=n;i.info("Creating boundary product..."),i.info("  boundaryId:",t),i.info("  productId:",e);try{let s={name:"Auditmation",description:"",productIds:[await w.parse(e)]};i.info("  createBoundaryProduct payload:",JSON.stringify(s));let c=await w.parse(t);await a.getBoundaryApi().createBoundaryProduct(c,s),i.info("Boundary product created successfully")}catch(r){i.info("Boundary product creation failed (may already exist)"),i.info("  Error message:",r.message),r.response&&(i.info("  Response status:",r.response.status),i.info("  Response data:",JSON.stringify(r.response.data)));let s=r.response?.data?.message||r.message||"";if(!s.includes("already exists")&&!s.includes("duplicate")){let c=new Error(`Failed to create boundary product in ensureBoundaryProduct(): ${r.message}`);throw c.stack=`${c.stack}
Caused by: ${r.stack}`,c}}i.info("Listing boundary products...");try{let r=await w.parse(t),c=(await a.getBoundaryApi().listBoundaryProductsByBoundary(r)).items.find(d=>d.productId.toString()===e);if(!c)throw new Error(`Boundary product not found for product ID: ${e}`);return i.info("Boundary product:",c.id),c.id}catch(r){let s=r,c=new Error(`Failed in listBoundaryProductsByBoundary(): ${s.message}`);throw c.stack=`${c.stack}
Caused by: ${s.stack}`,c}}async function T(n,t,e,a,r){let{platform:s}=n,c=r.pkgName.replace("@","").replace("/","-");i.info("Checking for existing pipeline...");try{i.info("  Searching for pipeline with name:",A);let d=await s.getPipelineApi().list(),o;if(d.items.length===0){i.info("Creating new pipeline...");let p={name:A,productId:a,boundaryId:t,boundaryProductId:e,description:`Auto generated pipeline from ${c} SBOMs`,timezone:C.Utc,targets:{},moduleName:"Auditmation",format:$.File,executionMode:R.Receiver,connectorType:N.ProductSpecific};i.info("  Pipeline payload:",JSON.stringify(p,null,2)),o=await s.getPipelineApi().create(p),i.info("Pipeline created successfully")}else i.info("Using existing pipeline"),[o]=d.items;return o.adminStatus===S.Draft?(i.info("Updating pipeline status from draft to created..."),o.adminStatus=S.Created,o=await s.getPipelineApi().update(o.id,o)):i.info(`Pipeline already in ${o.adminStatus} status, skipping status update`),i.info("Using pipeline:",o.id),o}catch(d){let o=d,p=new Error(`Failed in ensurePipeline(): ${o.message}`);throw p.stack=`${p.stack}
Caused by: ${o.stack}`,p}}async function q(n,t){let{platform:e}=n,a=await e.getPipelineJobApi().createPipelineJob({pipelineId:t,previewMode:!1});return i.info("Created job:",a.id),a}async function _(n,t,e){let{platform:a}=n,r=await a.getBatchApi().createBatch({className:"EvidenceFile",jobId:t,groupId:e});return i.info("Created batch:",r.id),r}async function G(n,t){let e=await n.getResourceApi().searchResources(void 0,void 0,["pipeline"],void 0,["folder"]),a=e.items?.find(s=>s.name==="pipeline")?.id;a||(a=(await n.getFolderApi().create({name:"pipeline"})).id),e=await n.getResourceApi().searchResources(void 0,void 0,[t.toString()],void 0,["folder"]);let r=e.items?.find(s=>s.name===t.toString())?.id;return r||(r=(await n.getFolderApi().create({name:t.toString(),folderId:a.toString()})).id),r}async function H(n,t,e,a,r,s,c){return new Promise((d,o)=>{let p=g.createReadStream(r),m={hostname:n.hostname,port:n.port,path:`/file-service/files/${a}/upload?checksum=${c}`,method:"POST",protocol:"https:",headers:{"content-length":s.toString(),"content-type":"application/json",Authorization:`APIKey ${t}`,"dana-org-id":e.toString()}},u="",l=E.request(m,y=>{y.on("data",h=>{let I=h.toString();i.info("Upload chunk received:",I),u+=I}),y.on("end",()=>{i.info("File upload completed");try{let h=JSON.parse(u);d(h.fileVersionId)}catch{o(new Error(`Failed to parse upload response: ${u}`))}})});l.on("error",y=>{i.error(`Error uploading file: ${y.message}`),o(y)}),p.pipe(l)})}async function Q(n,t,e,a){let{fileService:r}=n,{sbomFilePath:s,pkgName:c,version:d,fileSize:o,checksum:p}=e,m=await G(r,t),u=await r.getFileApi().create({name:`${c}-${d}.json`,description:`SBOM for ${c}`,folderId:m,retentionPolicy:{},syncPolicy:{}});i.info("File:",u.id),i.info("File object:",JSON.stringify(u,null,2));let l=u.fileVersionId?.toString()||"";return p===u.checksum?i.info("File checksum matches, skipping upload"):(l=await H(a.url,a.apiKey,a.orgId,u.id,s,o,p),i.info("File uploaded with new version:",l)),{...u,fileVersionId:l}}async function W(n,t,e,a,r){let{platform:s}=n,c={payload:{id:e.id,name:e.name,fileVersionId:e.fileVersionId,size:r,mimeType:"application/json",evidenceDefinition:L,pipelineId:a},rawData:{}};i.info("Adding batch item with payload:",JSON.stringify(c,null,2));let d=await s.getBatchApi().addBatchItem(t,c);i.info("Batch item:",d.id)}async function Z(n,t){let{platform:e}=n;await e.getPipelineJobApi().updatePipelineJob(t,{status:U.Completed})}async function X(n,t){let{platform:e}=n;await e.getBatchApi().endBatch(t)}async function Y(){try{let n=await j(),t=await z(n),e=await M(n),a=await V(e,n),r=await K(e,a,n.productId),s=await T(e,a,r,n.productId,t),c=await q(e,s.id),d=await _(e,c.id,t.pkgName),o=await Q(e,s.id,t,n);await W(e,d.id,o,s.id,t.fileSize),await Z(e,c.id),await X(e,d.id),i.info("SBOM upload completed successfully")}catch(n){let t=n;i.error("Error:",t.message),i.error("Stack:",t.stack),f.setFailed(t.message),process.exit(1)}}Y().catch(n=>{i.error("Unhandled error in run():",n),process.exit(1)});
//# sourceMappingURL=index.js.map
